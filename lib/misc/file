# $Revision$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# (c) Tim Brown, 2012
# <mailto:timb@nth-dimension.org.uk>
# <http://www.nth-dimension.org.uk/> / <http://www.machine.org.uk/>
#
# Supports: Linux, Solaris

. lib/misc/stdio

file_check_or_generate_cache () {
	if [ ! -f ${filecachefilename} ]
	then
		stdio_message_log "file" "Generating file cache..."
		# the below looks a bit odd but it's the best way to normalise file's output since we're not interested in inodes, device major/minor numbers etc
		# TODO what to do about symlinks, atm you'll get filename returned as /path/to/symlink -> /path/to/filename which isn't that helpful really
		find "${filecacherootpath}" -ls | sed "s/%/%%/g" | while read dummy dummy permissions dummy userid groupid dummy dummy dummy dummy restofline
		do
			if [ "`uname`" = "SunOS" ]
			then
				printf "${permissions} ${userid} ${groupid} ${restofline}\n"
			else
				printf -- "${permissions} ${userid} ${groupid} ${restofline}\n"
			fi
		done >"${filecachefilename}"
		stdio_message_log "file" "Cache generated..."
	fi
}

file_list_by_perm () {
	pattern="${1}"
	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"
	cat "${filecachefilename}" | egrep -- "${greppattern}" | while read permissions userid groupid filename
	do
		case "${permissions}" in
			${pattern})
				printf "${filename}\n"
				;;
		esac
	done
}

file_list_by_filename () {
	pattern="${1}"
	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"
	cat "${filecachefilename}" | egrep -- "${greppattern}" | while read permissions userid groupid filename
	do
		case "${filename}" in
			${pattern})
				printf "${filename}\n"
				;;
		esac
	done
}

file_show_perms () {
	pattern="${1}"
	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"
	cat "${filecachefilename}" | egrep -- "${greppattern}" | while read permissions userid groupid filename
	do
		case "${filename}" in
			${pattern})
				if [ "`uname`" = "SunOS" ]
				then
					printf "${filename} ${permissions} ${userid} ${groupid}\n"
				else
					printf -- "${filename} ${permissions} ${userid} ${groupid}\n"
				fi
				;;
		esac
	done
}

file_show_real_filename () {
	pattern="${1}"
	# TODO we could be smarter about this, but for now, which should suffice
	case "${pattern}" in
		/*)
			printf "${pattern}\n"
			;;
		*)
			printf "`which -- ${pattern}`\n"
			;;
	esac
}

file_matches_string () {
	pattern="${1}"
	pattern2="${2}"
	if [ -n "`cat "${pattern}" | egrep "${pattern2}"`" ]
	then
		printf "1\n"
	else
		printf "0\n"
	fi
}

file_parent_traverse () {
	filename="${1}"
	usergroupid="${2}"
	# start with the dependency itself and then use dirname to find the parent directory
	while [ "${filename}" != "/" ]
	do
		printf "${filename}\n"
		# find the parent directory
		filename="`dirname ${filename}`"
	done
}