#!/bin/sh
# $Revision$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# (c) Tim Brown, 2012
# <mailto:timb@nth-dimension.org.uk>
# <http://www.nth-dimension.org.uk/> / <http://www.machine.org.uk/>
#
# Supports: Linux, Solaris

. lib/misc/stdio

filecacherootpath="/"
filecachefilename="files_cache_no_sys.tmp"

file_check_or_generate_cache () {
	if [ ! -f ${filecachefilename} ]
	then
		stdio_message_log "file" "Generating file cache..."
		# the below looks a bit odd but it's the best way to normalise file's output since we're not interested in inodes, device major/minor numbers etc
		# TODO what to do about symlinks, atm you'll get filename returned as /path/to/symlink -> /path/to/filename which isn't that helpful really
		find "${filecacherootpath}" -ls | sed "s/%/%%/g" | while read _ _ permissions _ userid groupid _ _ _ _ restofline
		do
			if [ "`uname`" = "SunOS" ]
			then
				printf "${permissions} ${userid} ${groupid} ${restofline}\n"
			else
				printf -- "${permissions} ${userid} ${groupid} ${restofline}\n"
			fi
		done >"${filecachefilename}"
		stdio_message_log "file" "Cache generated..."
	fi
}

file_list_by_perm () {
	# always provide a pattern in the form "^?????????? ", for example:
	# "^?????w???? "
	# "^-??s?????? |^-??S?????? "
	pattern="${1}"

	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"

	egrep "${greppattern}" "${filecachefilename}" | while read _ _ _ filename _
	do
		printf "${filename}\n"
	done
}

file_list_by_filename () {
	# this function will return all files that match pattern, including
	# symlinks
	pattern="${1}"

	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"

	egrep " ${greppattern}$" "${filecachefilename}" | while read _ _ _ filename _
	do
		printf "${filename}\n"
	done
}

file_show_nonsymlink_perms () {
	# this function will return non-symlink files (and info) that match
	# pattern
	pattern="${1}"

	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"

	egrep "${greppattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		# exclude symlinked entries
		case "${permissions}" in
			l*)
				continue
				;;
			*)
				printf "${filename} ${permissions} ${userid} ${groupid}\n"
				;;
		esac
	done
}

file_show_perms () {
	# this function will return all files (and info) that match pattern,
	# including symlinks
	pattern="${1}"

	# this is expensive, so we cheat and use egrep
	greppattern="`echo ${pattern} | tr "?" "."`"

	egrep "${greppattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		printf "${filename} ${permissions} ${userid} ${groupid}\n"
	done
}

file_show_real_filename () {
	pattern="${1}"

	# TODO we could be smarter about this, but for now, which should suffice
	# Alternatives? whereis, updatedb/locate
	case "${pattern}" in
		/*)
			printf "${pattern}\n"
			;;
		*)
			printf "`which ${pattern}`\n"
			;;
	esac
}

file_show_symlinked_file () {
	symlink="${1}"
	egrep " ${symlink} -> " ${filecachefilename} | while read _ _ _ _ _ linkedfile
	do
		case "${linkedfile}" in
			/*)
				printf "${linkedfile}\n"
				;;
			*)
				if [ -n "${linkedfile}" ]
				then
					printf "`dirname ${symlink}`/${linkedfile}\n"
				else
					printf ""
				fi
				;;
		esac
	done
}

file_matches_string () {
	filename="${1}"
	pattern="${2}"
	if [ -n "`egrep "${pattern}" "${filename}"`" ]
	then
		printf "1\n"
	else
		printf "0\n"
	fi
}

file_parent_traverse () {
	filename="${1}"
	usergroupid="${2}"
	# start with the dependency itself and then use dirname to find the parent directory
	while [ "${filename}" != "/" ]
	do
		printf "${filename}\n"
		# find the parent directory
		filename="`dirname ${filename}`"
	done
}

file_check_or_generate_cache
