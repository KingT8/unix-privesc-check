#!/bin/sh
# $Revision$
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# (c) Tim Brown, 2012
# <mailto:timb@nth-dimension.org.uk>
# <http://www.nth-dimension.org.uk/> / <http://www.machine.org.uk/>
#
# Supports: AIX, Solaris, Linux

. lib/misc/stdio

filecachefilename="files_cache.temp"
filecacherootpath="/"

file_check_or_generate_cache () {
	if [ ! -f "${filecachefilename}" ]
	then
		stdio_message_log "file" "Generating file cache..."
		# the below looks a bit odd but it's the best way to normalise file's output since we're not interested in inodes, device major/minor numbers etc
		find "${filecacherootpath}" ! -type l -ls | sed "s/%/%%/g" | while read _ _ permissions _ userid groupid _ _ _ _ filename restofline
		do
			printf -- "${permissions} ${userid} ${groupid} ${filename} ${restofline}\n"
		done >"${filecachefilename}"
		stdio_message_log "file" "Cache generated..."
	fi
}

file_list_by_perm () {
	pattern="${1}"
	# patterns must always take the form "^.......... " i.e. regular expressions. for example "^...s...... |^....S...... " will select setuid binaries 
	egrep -- "${pattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		printf -- "${filename}\n"
	done
}

# TODO this will only work for files, not dirs - mostly what we want I think
file_list_by_filename () {
	pattern="${1}"
	# patterns must always take the form " /path/*/find" i.e. regular expressions
	egrep -- "^-.*${pattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		# TODO what if pattern matches on symlink? we may still revert to glob() style checking
		printf -- "${filename}\n"
	done
}

file_show_perms () {
	pattern="${1}"
	# patterns must always take the form " /path/*/find" i.e. regular expressions
	egrep -- "${pattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		# TODO what if pattern matches on symlink? we may still revert to glob() style checking
		printf -- "${filename} ${permissions} ${userid} ${groupid}\n"
	done
}

file_show_non_symlink_perms () {
	pattern="${1}"
	# patterns must always take the form " /path/*/find" i.e. regular expressions
	egrep -- "${pattern}" "${filecachefilename}" | while read permissions userid groupid filename _
	do
		case "${permissions}" in
			l?????????)
				continue
				;;
			*)
				printf -- "${filename} ${permissions} ${userid} ${groupid}\n"
				;;
		esac
	done
}

file_show_real_filename () {
	pattern="${1}"
	# TODO we could be smarter about this, but for now, which should suffice.. alternatives could include whereis, locate etc
	case "${pattern}" in
		/*)
			printf -- "${pattern}\n"
			;;
		*)
			# AIX errors to stdout, ideally we'd use $? but which on Solaris doesn't exit() differently depending on result :(
			# TODO maybe we should break it out with uname checks?
			realfilename="`which \"\`basename \\\"${pattern}\\\"\`\" 2>&1 | egrep -v \"There is no |^no \"`"
			if [ -n "${realfilename}" ]
			then
				printf -- "${realfilename}\n"
			fi
			;;
	esac
}

file_show_symlinked_filename () {
	pattern="${1}"
	# TODO we could be smarter about this, but for now, which should suffice.. alternatives could include whereis, locate etc
	egrep -- "${pattern} ->" "${filecachefilename}" | while read permissions userid groupid filename _ linkedfilename
	do
		case "${linkedfilename}" in
			/*)
				printf -- "${linkedfilename}\n"
				;;
			*)
				if [ -n "${linkedfilename}" ]
				then
					printf -- "`dirname \"${filename}\"`/${linkedfilename}\n"
				fi
				;;
		esac
	done
}

file_matches_string () {
	filename="${1}"
	pattern="${2}"
	if [ -n "`egrep \"${pattern}\" \"${filename}\"`" ]
	then
		printf -- "1\n"
	else
		printf -- "0\n"
	fi
}

file_parent_traverse () {
	filename="${1}"
	# start with the dependency itself and then use dirname to find the parent directory
	while [ "${filename}" != "/" ]
	do
		printf -- "${filename}\n"
		# find the parent directory
		filename="`dirname \"${filename}\"`"
	done
}

file_check_or_generate_cache
